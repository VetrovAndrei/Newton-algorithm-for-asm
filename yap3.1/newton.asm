.386
.MODEL FLAT, C

.DATA
	x0	DD 4.67 ; первоначальное значение и конечное значение
	x1	DQ ? ; значение функции в точке x0
	buf DQ ? ; значение производной в точке x0
	eps	DD ? ; эпсилон
	adres DD ? ; адрес на возвращаемое значение

	
.CODE
newton PROC
; Запишем переменные
PUSH EBP
MOV EBP, ESP
MOV EAX,[EBP]+8
MOV eps,EAX ; кладем в eps введенное значение
MOV EAX,[EBP]+12
MOV adres,EAX ; кладем в adres адрес на ячейку памяти, куда необходимо положить вычисленный X
XOR EDX, EDX ; зануляем "флаг"
XOR EBX, EBX ; зануляем счетчик
.WHILE DL == 0
	CALL func ; вызываем функцию вычисления функции в точке x0
	FLD eps ; кладем в стек эпсилон ST(0) = eps
	FLD x1 ; кладем в стек значение функции в точке x0 ST(0) = x1 ST(1) = eps
	FABS ; вычисляем значение x1 по модулю
	FCOMPP ; сравниваем ST(0) и ST(1), если первый больше второго
	FSTSW AX ; переходим по метке exit
	SAHF
	JNC exit
		INC EDX ; увеличиваем значение на 1, чтобы выйти из цикла
		JMP close ; переходим по метке в конец цикла
	exit:
	CALL iter ; вызываем функцию итерации
	INC EBX ; увеличиваем счетчик
	close:
.ENDW

MOV ECX , adres ; помещаем адрес на ячейку, в которой должен лежать Х
MOV EDX , x0 ; кладем в регистр значение X
MOV [ECX] , EDX ; кладем в ячейку памяти по адресу возвращаемого значения значение X

MOV EAX, EBX	; кладем значение счетчика в EAX, который вернется в СИ 
POP EBP
RET
newton ENDP

; вычисления производимые при одной итерации
iter PROC
	CALL derfunc ; вызов функции, которая посчитает производную функции и положит ее в buf
	FLD x0 ; кладем нынешнее значение х ST(0) = x0
	FLD x1 ; кладем значение функции в точке х0 ST(0) = x1 ST(1) = x0
	FLD buf ; кладем значение производной в точке х0 ST(0) = buf ST(1) = x1 ST(2) = x0
	FDIVP ; делим значение функции на значение производной ST(0) = x1/buf ST(1) = x0
	FSUBP ; отнимаем от х0 результат деления полученный в предыдущем пункте ST(0) = x0 - x1/buf
	FSTP x0 ; отправляем в x0 новое значение x0
	RET
iter ENDP

;процедура вычисления функции в точке
func PROC
	FLD x0 ; кладем значение x ST(0) = x0
	FLD ST ; дублируем его ST(0) = x0 ST(1) = x0
	FPTAN ; вызываем функцию вычисления тангенса x0 ST(0) = 1 ST(1) = tan(x0) ST(2) = x0
	FSTP ST ; выводим первый элемент из стека за ненадобностью ST(0) = tan(x0) ST(1) = x0
	FSUBRP ; отнимаем от первого второе ST(0) = tan(x0) - x0
	FSTP x1 ; отправляем в х1 значение функции в точке х0
	RET
func ENDP

;процедура вычисления производной в точке
derfunc PROC
	FLD1 ; кладем в стек единицу ST(0) = 1
	FLD1 ; кладем в стек единицу ST(0) = 1 ST(1) = 1
	FLD x0 ; кладем в стек х0 ST(0) = x0 ST(1) = 1 ST(2) = 1
	FCOS ; вычисляем значения косинуса х0 ST(0) = cos(x0) ST(1) = 1 ST(2) = 1
	FLD ST ; дублируем значения косинуса ST(0) = cos(x0) ST(1) = cos(x0) ST(2) = 1 ST(3) = 1
	FMULP ; возводим косинус в квадрат ST(0) = cos(x0)^2 ST(1) = 1 ST(2) = 1
	FDIVP ; делим 1 на косинус в квадрате ST(0) = 1 / cos(x0)^2 ST(1) = 1
	FSUBRP ; отнимаем от разности единицу ST(0) = 1 / cos(x0)^2 - 1
	FSTP buf ; отправляем в buf значение производной в точке х0
	RET
derfunc ENDP
END 
